## Non-parametric fitting with gaussian process regression
## Performs background removal using Gaussian Process Regression
## Generated by: M. Streeter (2020)
## Edited by: H. Poole (2025)

import numpy as np
from scipy.ndimage.filters import median_filter
from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import (RBF, Matern, RationalQuadratic,
                                              ExpSineSquared, DotProduct,
                                              ConstantKernel, WhiteKernel)
from scipy.interpolate import interp1d, interp2d, RectBivariateSpline
from sklearn.utils._testing import ignore_warnings
from sklearn.exceptions import ConvergenceWarning

from scipy.ndimage import gaussian_filter
import matplotlib.pyplot as plt

class GP_beam_fitter():
    """ 
    A class for fitting beam profiles using gaussian process regression
    This is a non-parameteric beam fitting method
    Parameters
    ----------
    beam_mask : np.array(float or int)
        An array which has the same shape as your image but takes a value of 1 or
        0 for pixels which should be included (1) or omitted (0) from the fitting
        
    N_samples : int (optional)
        number of points to sample from the beam to include in the fitting
        takes a default value of 1000

    N_pred  : tuple (optional)
        number of points in x and y to sample the GPR model to build the beam profile
        the final profile will be interpolated from this to match the shape of beam_mask
    
    """
    
    def __init__(self,beam_mask,N_samples = 1000, N_pred =(100,100)):
        self.beam_mask = beam_mask
        self.mask_ind = np.nonzero(beam_mask.flatten())
        self.N_samples = int(N_samples)
        self.N_pred = N_pred

        # gaussian process model for fitting beam profle
        kernel = 1.0**2* Matern(
            length_scale=0.1, length_scale_bounds=(1e-2, 10.0),nu=1.5
        ) + WhiteKernel(1e-2)

        self.gp = GaussianProcessRegressor(kernel=kernel)

        
        self.x,self.y,self.XY = self._make_image_grid(beam_mask)
        self.x_pred,self.y_pred,self.XY_pred = self._make_image_grid(np.ones(N_pred))
        self._determine_pixel_weights()
        
        
    def _make_image_grid(self,img):
        """
        Makes a grid from the dimension of the image
        Parameters
        ----------
        img : np.array(float or int)
        

        Returns
        -------
        x : np.array from -1 to 1 in img.shape[1] points
        x : np.array from -1 to 1 in img.shape[1] points
        XY : array of x and y points from meshgrid
        
        """
        x = np.linspace(-1,1,num=img.shape[1],endpoint=True)
        y = np.linspace(-1,1,num=img.shape[0],endpoint=True)
        [X,Y] = np.meshgrid(x,y)
        XY = np.array([X.flatten(),Y.flatten()]).T
        return x,y,XY
        
    def _determine_pixel_weights(self):
        """
        Function to give each pixel a weight for the random particle selection
        """
        bmf = gaussian_filter(self.beam_mask,100)
        pixel_w = 1/bmf.flatten()[self.mask_ind]
        self.pixel_w = pixel_w/np.sum(pixel_w)

    def fit_beam(self,img):
        """
        Fits the masked region of the input image
        Parameters
        ----------
        img : np.array(float or int)
        This is the image containing the beam to be fitted
        

        Returns
        -------
        beam_img : np.array predicted beam with same array size as img
        beam_unc : np.array uncertainty in predicted beam with same array size as img
        
        """  
        imgMax = np.max(img)
        imgMin = np.min(img)
        img = img.astype(float)
        I  = (median_filter(img,2).flatten()-imgMin)/(imgMax-imgMin)
        I_index = np.arange(len(I))

        selected_index = np.random.choice(I_index[self.mask_ind],
                                          size=np.clip(self.N_samples,1,self.mask_ind[0].size),
                                          replace=False,p=self.pixel_w)

        x_train = self.XY[selected_index,:]
        I_train = I[selected_index]
        with ignore_warnings(category=ConvergenceWarning):
            self.gp.fit(x_train,I_train)
       

        I_pred,I_pred_err = self.gp.predict(self.XY_pred,return_std=True)
        I_pred = I_pred.reshape(self.N_pred)
        I_pred_err = I_pred_err.reshape(self.N_pred)

        beam_img = RectBivariateSpline(self.y_pred,self.x_pred,I_pred)(self.y,self.x)*(imgMax-imgMin)+imgMin
        beam_unc = RectBivariateSpline(self.y_pred,self.x_pred,I_pred_err)(self.y,self.x)*(imgMax-imgMin)
        
        ratio_img = median_filter(img/beam_img,5)
        null_ratio_vals = ratio_img[np.nonzero(self.beam_mask)]
        null_ratio_mean = np.mean(null_ratio_vals)
        null_ratio_rms = np.std(null_ratio_vals,dtype=np.float64)
        print(f'Null beam ratio mean = {null_ratio_mean:1.06f}')
        print(f'Null beam ratio rms = {null_ratio_rms:1.06f}')

        return beam_img, beam_unc
        
